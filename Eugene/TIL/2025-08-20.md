# 📕 Chapter 05 CPU 성능 향상 기법

## ✅ 05-1 빠른 CPU를 위한 설계 기법

### 📌 클럭

    - 컴퓨터 부품들은 '클럭 신호'에 맞춰 일사분란하게 움직인다
    - CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어들을 실행한다
    ➡️ 클럭 신호가 빠르게 반복되면 명령어 사이클도 더 빠르게 반복할 것

- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋음
- `클럭 속도` : 헤르츠(Hz) 단위로 측정, 1초에 클럭이 몇번 반복되는지
- 클럭 속도가 항상 일정하지는 않음
- 고성능이 필요한 순간에는 클럭 속도를 높이고, 그렇지 않을 때는 낮추기도 함
- `오버클러킹` : 최대 클럭 속도를 강제로 끌어올림
- 클럭 속도를 매우 높이면 발열 심각
- 무작정 클럭 속도를 높이는 것만으로는 성능 향상에 한계

### 📌 코어와 멀티코어

- **`코어`** : CPU의 정의인 **명령어를 실행하는 부품**
- CPU 내부에 코어가 여러개 존재할 수 있음
- `멀티코어 CPU` | `멀티코어 프로세서` : 코어를 여러 개 포함하고 있는 CPU
- 단일 코어보다 멀티 코어의 처리 속도가 빠르다
- 코어 수에 비례하여 속도가 빨라지는 것은 아님

### 📌 스레드와 멀티스레드

- 스레드 : 실행 흐름의 단위
  - [하드웨어적 스레드](#-하드웨어적-스레드)
  - [소프트웨어적 스레드](#-소프트웨어적-스레드)

### 🔍 하드웨어적 스레드

- `하드웨어 스레드` : 하나의 코어가 동시에 처리하는 명령어 단위
- `멀티스레드 CPU` | `멀티스레드 프로세서` : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
  - **레지스터**가 가장 큰 핵심
  - 레지스터 세트가 여러벌 있으면 그 개수만큼 명령어를 처리하기 위한 정보를 기억할 수 있음
- 예) 8코어 16 스레드 CPU > 코어 하나당 2개의 하드웨어 스레드를 처리
- `하이퍼스레딩` : intel의 멀티스레드 기술
- **`논리 프로세서`** 라고도 함
  - 메모리 속 프로그램 입장에서 하드웨어 스레드가 마치 한 번에 하나의 명령어를 처리하는 CPU처럼 보이기 때문

### 🔍 소프트웨어적 스레드

- `소프트웨어적 스레드` : 하나의 프로그램에서 독립적으로 실행되는 단위
- 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수 있지만 여러 부분이 동시에 실행되기도 함
- 여러 기능을 각각의 스레드로 만들어 동시에 실행 가능

## ✅ 05-2 명령어 병렬 처리 기법

### 📌 명령어 파이프라인

    클럭 단위로 나눈 일반적인 명령어 처리 과정

    1. 명령어 인출(Instruction Fetch)
    2. 명령어 해석(Instruction Decode)
    3. 명령어 실행(Execute Instruction)
    4. 결과 저장(Write Back)

- 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있음
- **`명령어 파이프라이닝`** : 공장 생산 라인과 같이 명령어들을 `명령어 파이프라인`에 넣고 동시에 처리하는 기법
- 파이프라이닝으로 성능을 높일 수 있지만 특정 상황에서는 성능 향상에 실패할 수 있음
- **`파이프라인 위험`** : 성능 향상에 **실패**하는 상황
  - [`데이터 위험`](#-데이터-위험)
  - [`제어 위험`](#-제어-위험)
  - [`구조적 위험`](#-구조적-위험)

### 🔍 데이터 위험

- 명령어 간 **데이터 의존성**에 의해 발생

      [예시]
      명령어 1: R1 ← R2 + R3
      (R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장)
      명령어 2: R4 ← R1 + R5
      (R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장)

- 명령어 1을 수행해야만 명령어 2를 수행할 수 있음
- `데이터 위험` : **데이터 의존적**인 두 명령어를 무작정 동시에 실행하려고 할 때 파이프라인이 제대로 작동하지 않는 것

### 🔍 제어 위험

- 분기 등으로 인한 프로그램 카운터의 **갑작스런 변화**에 의해 발생
- 예) 10번지 명령어 실행 결과로 60번지 명령어로 분기 ➡️ 엥? 미리 처리중이던 11번지 12번지 헛수고하셨습니다~
- `분기 예측` : 프로그램이 어디로 분기할지 미리 예측 후 주소 인출

### 🔍 구조적 위험

- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 **같은 CPU 부품**을 사용하려 할 때 발생
- `자원 위험` 이라고도 함

### 📌 슈퍼스칼라

- 대부분의 CPU에서 여러 개의 파이프라인을 이용
- `슈퍼스칼라` : CPU 내부어 여러 개의 명령어 파이프라인을 포함한 구조
- `슈퍼스칼라 CPU` | `슈퍼스칼라 프로세서` : 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
- 파이프라인 위험 등 예상치 못한 이유로 파이프라인 개수와 처리 속도가 정비례하진 않음

### 📌 비순차적 명령어 처리

- `비순차적 명령어 처리 기법` : 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행해 명령어 파이프라인이 멈추는 것을 방지하는 기법

## ✅ 05-3 CISC과 RISC

### 📌 명령어 집합

- **`ISA`**(Instruction Set Architecture) | `명령어 집합` | `명령어 집합 구조` : CPU가 이해할 수 있는 명령어의 모음
- 제조사마다, 각 CPU마다 ISA 다를수도 ➡️ 어셈블리어도 달라짐
  - 인텔칩과 ARM칩은 서로의 명령어를 이해할 수 없도다 ..
- ISA 차이가 CPU 하드웨어 설계에 큰 영향을 미침
- CPU의 언어이자 CPU를 비롯한 **하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속**
- 명령어 병렬 처리 기법을 적용하기 유리한 ISA도 있고 아닌 ISA도 있음

### 📌 CISC

- Complex Instruction Set Computer
- 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
- x86, x86-64가 해당
- 다양하고 강력한 기능의 명령어 집합 활용
- 명령어 형태와 크기가 다양한 `가변 길이 명령어` 활용
  - 메모리에 접근하는 주소 지정 방식이 다양함
- 상대적으로 적은 수의 명령어로 프로그램 실행
  - 컴파일된 프로그램의 크기가 상대적으로 작음
    - 같은 소스코드라도 CPU마다 생성되는 실행 파일의 크기 상이
  - 메모리 공간을 절약할 수 있음
- 단점

  - 명령어의 크기와 실행 시간이 일정치 않음
  - 명령어 하나를 실행하는 데 여러 클럭 주기 필요
    <br>
    ➡️ 명령어 규격화가 어려워 명령어 파이프라인 효율 ↓ 😱
  - 어차피 복잡한 명령어 자주 쓰는 것도 아님;;

### 📌 RISC

<blockQuote>
CISC가 우리에게 준 교훈

- 빠른 처리 위해 명령어 파이프라이닝 필수!! 원활한 파이프라이닝을 위해 **명령어 길이와 수행 시간이 짧고 규격화** 되어야
- 어차피 쓰는 명령어만 씀;; 복잡한 기능 보다는 **자주 쓰는 기본 명령어를 작고 빠르게** 만들자
</blockQuote>

- Reduced Instruction Set Computer
- CISC에 비해 명령어의 종류가 적다
- 짧고 규격화 된 명령어, 되도록 1클럭 내외로 실행되는 명령어 지향
- `고정 길이 명령어` 활용
- 메모리 접근 단순화 / 최소화
  - 메모리에 직접 접근하는 명령어 load, store 두 가지로 제한
    - `load-store 구조`라고도 함
  - CISC보다 주소 지정 방식 종류가 적은 편
- 레지스터 적극 활용
- 사용 가능한 명령어 종류가 적어 같은 소스코드라도 CISC에 비해 더 많은 명령어 필요
- ARM 해당

### 📍 CISC vs RISC

| CISC                                 | RISC                                 |
| ------------------------------------ | ------------------------------------ |
| 복잡하고 다양한 명령어               | 단순하고 적은 명령어                 |
| 가변 길이 명령어                     | 고정 길이 명령어                     |
| 다양한 주소 지정 방식                | 적은 주소 지정 방식                  |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행         | 1클럭 내외로 명령어 수행             |
| 파이프라이닝 어려움                  | 파이프라이닝 쉬움                    |
