# 📕 Chapter 01 컴퓨터 구조 시작하기

## ✅ 01-1 컴퓨터 구조를 알아야 하는 이유

`컴퓨터 구조`는 실력있는 개발자가 되기 위한 기본 지식!

문제의 실마리를 빠르게 찾아 **`문제 해결 능력`** 향상

**`성능/용량/비용`** 을 고려하는 개발자가 될 수 있다!

## ✅ 01-2 컴퓨터 구조의 큰 그림

### 📌 컴퓨터 구조의 큰 그림

    컴퓨터 구조
    	- 컴퓨터가 이해하는 정보
    		- 데이터
    		- 명령어
    	- 컴퓨터의 네 가지 핵심 부품
    		- CPU
    		- 메모리
    		- 보조기억장치
    		- 입출력장치

### 📌 컴퓨터가 이해하는 정보

컴퓨터는 0과 1로 표현된 정보만을 이해

0과 1로 표현된 정보에는 `데이터`, `명령어` 두 가지

- **`데이터`** : 컴퓨터가 이해하는 정적인 정보
- **`명령어`** : 컴퓨터를 작동시키는 정보

  → 컴퓨터란? 명령어를 처리하는 기계

### 📌 컴퓨터의 네 가지 핵심 부품

- [메모리](#-메모리주기억장치)
- [CPU](#-cpu중앙처리장치)
- [보조기억장치](#-보조기억장치)
- [입출력장치](#-입출력장치)

### 🔍 메모리(주기억장치)

메모리에는 RAM(Random Access Memory), ROM(Read Only Memory) 두 가지가 있으나 일반적으로 RAM을 지칭

- **현재 실행**되는 프로그램의 **명령어와 데이터를 저장**하는 부품
- 저장된 값의 위치는 **주소**로 알 수 있음
- 일시적

### 🔍 CPU(중앙처리장치)

- 컴퓨터의 두뇌
- 메모리에 저장된 **명령어를 읽고, 해석하고, 실행**함
- 내부 구성 요소로 `ALU`, `레지스터`, `제어장치` 등이 있음
- **`ALU(산술논리연산장치)`** : 컴퓨터 내부의 연산을 처리
- **`레지스터`** : 프로그램을 실행하는 데에 필요한 값들을 CPU 내부에 임시로 저장
- **`제어장치`** : `제어신호`라는 전기 신호를 내보내고 명령어를 해석
  - 메모리에 `저장된 값을 읽고` 싶을 때 `메모리 읽기` 제어 신호 송신
  - 메모리에 `어떤 값을 저장`하고 싶을 때 `메모리 쓰기` 제어 신호 송신

### 🔍 보조기억장치

- 메모리는 가격이 비싸 저장 용량이 적다는 것과 전원이 꺼지면 저장된 내용을 잃는다는 단점이 있음
- 컴퓨터의 전원이 꺼져도 저장된 내용을 잃지 않는 보조 저장 장치

### 🔍 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품

### 🔍 메인보드와 시스템 버스

- **`메인보드`**(마더보드) : 컴퓨터의 핵심 부품들을 연결하는 판
- `버스` : 메인보드에 연결된 부품들이 서로 정보를 주고 받는 통로
- **`시스템 버스`** : 컴퓨터의 네 가지 핵심 부품이 서로 정보를 주고 받는 통로
  - 시스템 버스는 `주소 버스`, `데이터 버스`, `제어 버스`로 구성
  - `주소 버스` : 주소를 주고 받는 버스
  - `데이터 버스` : 명령어와 데이터를 주고 받는 버스
  - `제어 버스` : 제어신호를 주고 받는 버스

# 📕 Chapter 02 데이터

## ✅ 02-1 0과 1로 숫자를 표현하는 방법

### 📌 정보 단위

컴퓨터가 이해하는 정보는 0과 1로 이루어져 있음

|                    |                                      |
| ------------------ | ------------------------------------ |
| **비트(bit)**      | 0과 1을 나타내는 가장 작은 정보 단위 |
| **바이트(byte)**   | 8비트                                |
| **킬로바이트(kB)** | 1000바이트                           |
| **메가바이트(MB)** | 1000킬로바이트                       |
| **기가바이트(GB)** | 1000메가바이트                       |
| **테라바이트(TB)** | 1000기가바이트                       |
|                    |                                      |

### 📌 이진법

- `이진법` : 수학에서 0과 1만으로 모든 숫자를 표현하는 방법
  - 숫자가 1을 넘어가는 시점에 자리 올림
  - `이진수` : 이진법으로 표현된 수
- 아래첨자(2) 또는 0b를 앞에 붙여 표시
- 이진수의 음수는 `2의 보수`로 표현할 수 있음
  - `2의 보수`
    - 사전적 의미 : 어떤 수를 그보다 큰 2^n에서 뺀 값
    - 모든 0과 1을 뒤집고 1을 더한 값
  - 양수와 음수를 구분하기 위해 `플래그` 사용

### 📌 십육진법

- `십육진법` : 수가 15를 넘어가는 시점에서 자리올림
- 아래첨자(16) 또는 0x를 앞에 붙여 표시
- 이진법으로 모든 숫자를 표기하려면 숫자의 길이가 길어진다는 단점
- 십육진법 ↔ 이진법 간 변환이 간단하기 때문에 사용

## ✅ 02-2 0과 1로 문자를 표현하는 방법

### 📌 문자 집합과 인코딩

- `문자 집합` : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- `문자 인코딩` : 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정
- `문자 디코딩` : 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정

### 📌 아스키 코드(ASCII)

- 영어 알파벳, 아라비아 숫자, 일부 특수문자 포함
- 7비트 → 2^7개로 표현 가능 = 총 128개의 문자
- 장점 : 인코딩이 간단함
- 단점 : 표현할 수 있는 문자가 적음
- 8비트로 이루어진 확장아스키 등장했으나 256개로 여전히 적음

### 📌 EUC-KR

한글의 인코딩 방식은 `완성형 인코딩` 또는 `조합형 인코딩`

- `완성형 인코딩` : 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 방식
- `조합형 인코딩` : 초성, 중성, 종성 각각을 위한 비트열을 할당하여 그들의 조합으로 하나의 글자코드를 완성하는 방식
- EUC-KR은 대표적인 **완성형 인코딩** 방식
- 한글 단어 하나에 2byte의 크기
- 모든 한글 조합을 표현할 수 없다는 한계 있음

### 📌 유니코드와 UTF

- `유니코드` : 여러 나라의 문자들을 광범위하게 표현할 수 있는 통일된 문자 집합
- `UTF-8` : UTF-8, UTF-16, UTF-32 등 유니코드의 여러가지 인코딩 방법 중 가장 대중적인 것

# 📕 Chapter 03 명령어

## ✅ 03-1 소스코드와 명령어

### 📌 고급 언어와 저급 언어

사람이 작성하는 소스코드를 통해 프로그램을 실행시키기 위해서는 컴퓨터 내부에서 명령어로 변환하는 과정을 필요로 함

- `고급 언어` : 사람이 이해하고 작성하기 쉽게 만들어진 언어
- `저급 언어` : 컴퓨터가 이해하고 실행할 수 있는 언어
  - `기계어` : 0과 1로 이루어진 명령어 모음
  - `어셈블리어` : 기계어를 사람이 읽기 편한 형태로 번역한 언어

### 📌 컴파일 언어와 인터프리터 언어

고급 언어를 저급 언어로 변환하는 방식에는 `컴파일 방식`, `인터프리트 방식` 두 가지

### 🔍 컴파일 언어

- `컴파일 언어` : 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어

- `컴파일` : 소스코드 전체가 저급언어로 변환되는 과정
- `컴파일러` : 컴파일을 수행하는 도구
- `목적코드` : 컴파일러를 통해 저급 언어로 변환된 코드
- 코드 전체를 **한번에** 변환하기 때문에 한줄이라도 오류가 있으면 컴파일에 실패

### 🔍 인터프리터 언어

- `인터프리터 언어` :인터프리터에 의해 소스코드가 한 줄씩 실행되는 고급 언어
- `인터프리터` : 소스코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구
- 코드를 **한 줄씩** 실행하기 때문에 오류가 있더라도 오류를 발견하기 전까지의 코드는 실행

### 🔖 목적파일 vs 실행파일

- `목적파일` ≠ `실행파일`
- 목적코드가 실행파일이 되기 위해서는 `링킹` 필요

## ✅ 03-2 명령어의 구조

### 📌 연산 코드와 오퍼랜드

- `명령어` = **`연산코드`** + **`오퍼랜드`**

### 🔍 오퍼랜드(operand, 피연산자)

- 연산에 **사용할 데이터**
- `오퍼랜드 필드` : 오퍼랜드가 담기는 영역
- 데이터를 직접 명시하기 보다는 사용할 데이터의 **메모리 주소**나 **레지스터 이름**이 담김
- `주소 필드` 라고도 함
- 명령어 안에 0-N개가 있을 수 있음
  - 오퍼랜드의 개수에 따라 `0-주소 명령어`, `1-주소 명령어`, `2-주소 명령어`, `3-주소 명령어`

### 🔍 연산 코드(operation code, 연산자)

- 명령어가 **수행할 연산**
- `연산 코드 필드` : 연산 코드가 담기는 영역
- 기본적인 연산 코드 유형
  1. 데이터 전송
  2. 산술/논리 연산
  3. 제어 흐름 변경
  4. 입출력 제어

### 📌 주소 지정 방식

오퍼랜드 필드에 데이터를 직접 명시하지 않고 데이터의 위치를 담는 이유?

- 명령어의 총 크기에서 연산코드의 크기를 빼고, 오퍼랜드의 개수만큼 나누면 **오퍼랜드 필드 하나당 표현할 수 있는 정보의 크기가 매우 제한적**
- 오퍼랜드 필드에 메모리 주소/레지스터 이름을 담으면 **하나의 메모리 주소/레지스터의 크기만큼의 정보를 표현할 수 있음**
- `유효 주소` : 연산의 대상이 되는 데이터가 저장된 위치
- **`주소 지정 방식`** : 연산에 사용할 데이터 위치를 찾는 방법
  - [즉시 주소 지정 방식](#-즉시-주소-지정-방식)
  - [직접 주소 지정 방식](#-직접-주소-지정-방식)
  - [간접 주소 지정 방식](#-간접-주소-지정-방식)
  - [레지스터 주소 지정 방식](#-레지스터-주소-지정-방식)
  - [레지스터 간접 주소 지정 방식](#-레지스터-간접-주소-지정-방식)

### 🔍 즉시 주소 지정 방식

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 다른 주소 지정 방식보다 빠르다
- 표현할 수 있는 데이터의 크기가 제한적

### 🔍 직접 주소 지정 방식

- 오퍼랜드 필드에 유효주소(메모리주소)를 직접적으로 명시
- 표현할 수 있는 데이터의 크기가 즉시 주소 지정 방식보다 큼
- 여전히 연산 코드의 비트 수만큼 표현할 수 있는 유효 주소에 제한 있음

### 🔍 간접 주소 지정 방식

- 오퍼랜드 필드에 유효주소의 주소를 명시
- 표현할 수 있는 유효주소의 범위가 넓음
- 메모리에 두번 접근해 속도가 느림

### 🔍 레지스터 주소 지정 방식

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- **일반적으로 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠름**
- 직접 주소 지정 방식보다 빠르다
- 표현할 수 있는 레지스터 크기에 제한 있음

### 🔍 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장하고 해당 유효주소를 저장한 레지스터를 오퍼랜드 필드에 명시
- 메모리에 접근하는 횟수를 한번으로 줄여 간접 주소 지정 방식보다 빠르다

### 🔖 스택과 큐

- **`스택`** : LIFO 후입선출
- **`큐`** : FIFO 선입선출
