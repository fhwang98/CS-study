# Chap 5. CPU 성능 향상 기법

## 01. 빠른 CPU를 위한 설계 기법

### 클럭

**✨review**

1. 컴퓨터 부품들은 '클럭 신호'에 맞춰 일사불란하게 움직인다.
2. CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어들을 실행한다.

→ 클럭 속도 높아짐 > 명령어 사이클 더 빠르게 반복 > 다른 부품들도 더 빨리 작동

💡 일반적으로 클럭 속도가 높은 CPU는 성능이 좋음 !!

`클럭 속도` = 헤르츠(Hz) 단위로 측정 → 1초에 클럭이 몇 번 반복되는지 나타냄

> ⚡️ **클럭 속도는 일정하지 않다!**  
> 기본 클럭 속도, 최대 클럭 속도로 나뉘어 있음  
> → 고성능을 요하는 순간에 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도 조정  
> ✔️ 오버클럭킹 = 최대 클럭 속도를 강제로 더 끌어올리는 기법

**[클럭 속도를 무작정 높이면 안되는 이유]**  
그래픽이 많이 요구되는 게임이나 영상 편집 등이 CPU에 무리가 가는 작업을 장시간 하면 컴퓨터가 뜨겁게 달아오름
→ 발열 문제 발생, 심각해짐!

💡 클럭 속도만으로 CPU의 성능을 올릴 수 X

### 코어와 멀티코어

**[CPU의 성능을 높이는 방법]**

- 클럭 속도 높이기
- CPU의 코어와 스레드 수 늘리기

> ✔️ **코어(core)**  
> CPU 내에서 명령어를 실행하는 부품으로 여러 개 있을 수 있음
>
> 과거 = '명령어를 실행하는 부품'이 CPU 하나만 존재  
> 현재 = 기술 발전으로 '코어'라는 명령어를 실행하는 부품이 추가됨
>
> 💡 오늘 날의 CPU는 단순히 '명령어를 실행하는 부품'이 아니라 '**명령어를 실행하는 부품을 여러 개 포함하는 부품**'

<br>

**멀티코어 CPU (멀티코어 프로세스)**  
코어를 여러 개 포함하고 있는 CPU  
ex. 듀얼코어 / 트리플코어 / 쿼드코어 / 헥사코어 / 옥타코어 / 데카코어 / 도데카코어 ...

⚡️ 코어를 늘린다고 연산 처리 속도가 똑같이 2배, 3배.. 이상으로 빨라지지 않는다!  
ex. 조별과제

<br>

### 스레드와 멀티스레드

`스레드` = 실행 흐름의 단위

- 하드웨어적 스레드 (CPU에서 사용)
- 소프트웨어적 스레드 (프로그램에서 사용)

**[하드웨어적 스레드]**  
하나의 코어가 동시에 처리하는 명령어 단위

**멀티 스레드 프로레서 (멀티스레드 CPU)**  
하나의 코어로 여러 명령어를 동시에 처리하는 CPU

> `하이퍼스레딩` = 인텔의 멀티스레드 기술

<br>

**[소프트웨어적 스레드]**  
하나의 프로그램에서 독립적으로 실행되는 단위  
→ 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있음

<br>

**[멀티스레드 프로세서]**  
멀티스레드 프로세서에서 가장 중요한 개념은 **레지스터**  
프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 **하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러 개** 가지고 있어야 함

⚡️ 메모리 속 프로그램 입장에서 봤을 때, 하드웨어 스레드는 마치 '한 번에 하나의 명령어를 처리하는 CPU'  
ex. 2코어 4스레드 CPU는 한 번에 네 개의 명령어를 처리 but 프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 4개  
➡️ 그래서 하드웨어 스레드를 `논리 프로세서` 라고도 부름

> ✨ **정리**  
> `코어` = 명령어를 실행할 수 있는 하드웨어 부품  
> `스레드` = 명령어를 실행하는 단위  
> `멀티코어 프로세서` = 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU  
> `멀티스레드 프로세서` = 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

<br>

## 02. 명령어 병렬 처리 기법

명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법

### 명령어 파이프라인

**[명령어 처리 과정]**  
① 명령어 인출 Instruction Fetch  
② 명령어 해석 Instruction Decode  
③ 명령어 실행 Execute Instruction  
④ 결과 저장 Write Back  
⚡️ 같은 단계가 겹치지만 않는다면 CPU는 **각 단계를 동시에 실행**할 수 있음!

<img src="images/명령어파이프라인.png" alt="pipeline" width="600">

→ `명령어 파이프라이닝` : 동시에 여러 개의 명령어를 겹쳐 실행하는 기법

**파이프라인 위험**  
파이프라이닝은 높은 성능을 가져오지만 특정 상황에서 성능 향상에 실패

- 데이터 위험
- 제어 위험
- 구조적 위험

**[데이터 위험]**  
명령어 간 '데이터 의존성'에 의해 발생  
데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않음

**[제어 위험]**  
주로 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생  
기본적으로 프로그램 카운터는 **현재 실행 중인 명령어의 다음 주소**로 갱신
`분기 예측` = 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술

**[구조적 위험]**  
명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생  
= `자원 위험`

### 슈퍼스칼라

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조

`슈퍼스칼라 프로세서`(슈퍼스칼라 CPU) = 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU  
매 클럭 주기마다 동시에 여러 명령어 인출과 실행이 가능해야함  
→ 멀티스레드 프로세서는 한 번에 여러 명령어를 인출, 해석, 실행 가능하기 때문에 슈퍼스칼라 구조 사용 가능 !

⚡️ 슈퍼스칼라 프로세서는 반드시 파이프라인 개수에 비례하여 빨라지지는 않음  
파이프라인 위험 등의 예상치 못한 문제 존재, 더 고도로 설계되어야 함!

### 비순차적 명령어 처리

명령어들을 순차적으로 실행하지 않는 기법  
Out-of-order execution → `OoOE`

💡 비순차적 명령어 처리가 가능한 CPU는 명령어들이 **어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지를 판단**할 수 있어야 함

<br>

## 03. CISC와 RISC

### 명령어 집합

CPU가 이해할 수 있는 명령어들의 모음  
= `ISA` 명령어 집합 구조(Instruction Set Architecture)

⚡️ CPU마다 ISA가 다를 수 있음  
→ ISA는 일종의 CPU의 언어  
ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속

### CISC

이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식  
(Complex Instruction Set Computer)

CISC는 다양하고 강력한 기능의 명령어 집합을 활용  
→ `가변 길이 명령어` 활용  
'적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다'는 장점 = 메모리 공간 절약

🚨 CISC의 단점

- 명령어가 복잡하고 다양한 기능을 제공하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
- 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기 필요  
  → 명령어 파이프 라인을 구현하는데 큰 걸림돌

> CISC의 명령어 파이프라인  
> 명령어 수행시간이 길고 가지각색  
> → 파이프라인이 효율적으로 명령어 처리 불가
>
> <img src="images/cisc pipeline.png" alt="pipeline" width="600">
>
> 규격화 되지 않은 명령어가 파이프라이닝을 어렵게 만듦

✨ CISC 정리

- 복잡하고 다양한 기능을 제공, 적은 수의 명령으로 프로그램 동작 + 메모리 절약
- 명령어의 규격화가 어려워 파이프라이닝 어려움
- 대다수의 복잡한 명령어는 사용 빈도가 낮음  
  → CISC 기반 CPU는 성장에 한계

💡 **CISC의 한계가 주는 교훈**  
① 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 함  
 원활한 파이프라이닝을 위해 '명령어 길이와 수행 시간이 짧고 규격화'되어 있어야 함!  
② 어차피 자주 쓰이는 명령어만 사용  
 복잡한 기능을 지원하는 명령어를 추가하기 보다는 '자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것'이 중요

### RISC

단순하고 적은 수의 `고정 길이 명령어` 집합 활용  
(Reduced Instruction Set Computer)  
→ 명령어가 규격화되어 있고, 하나의 명령어가 1크럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화!

RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한 → `load-store 구조`  
메모리 접근 최소화, **레지스터 적극 활용**

<br>

✨ **CISC vs RISC**

| 구분                   | CISC                             | RISC                             |
| ---------------------- | -------------------------------- | -------------------------------- |
| **명령어 복잡도**      | 복잡하고 다양한 명령어           | 단순하고 적은 명령어             |
| **명령어 길이**        | 가변 길이 명령어                 | 고정 길이 명령어                 |
| **주소 지정 방식**     | 다양한 주소 지정 방식            | 적은 주소 지정 방식              |
| **프로그램 명령어 수** | 프로그램을 이루는 명령어 수 적음 | 프로그램을 이루는 명령어 수 많음 |
| **명령어 수행 시간**   | 여러 클럭에 걸쳐 명령어 수행     | 1클럭 내외 명령어 수행           |
| **파이프라이닝**       | 파이프라이닝 어려움              | 파이프라이닝 쉬움                |
